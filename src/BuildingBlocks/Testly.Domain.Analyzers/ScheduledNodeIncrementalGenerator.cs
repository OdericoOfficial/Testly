using System.Text;
using static Testly.Domain.Analyzers.ScheduledNodeSyntaxProvider;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Testly.Domain.Analyzers
{
    [Generator]
#pragma warning disable RS1036 // 指定分析器禁止的 API 强制设置
    internal class ScheduledNodeIncrementalGenerator : IIncrementalGenerator
#pragma warning restore RS1036 // 指定分析器禁止的 API 强制设置
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterSourceOutput(context.SyntaxProvider.CreateSyntaxProvider(Predicate, Transform), (context, symbol) =>
            {
                var builder = new StringBuilder();
                builder.AppendLine("// <auto-generated />");
                builder.AppendLine();
                builder.AppendLine("using Orleans.Streams;");
                builder.AppendLine("using Testly.Domain.Events;");
                var nameBuilder = new StringBuilder();
                nameBuilder.Append(symbol.IsAbstract ? "public abstract partial class " : "internal sealed partial class ");
                nameBuilder.Append(symbol.Name);
                if (symbol.TypeParameters.Length > 0)
                {
                    nameBuilder.Append("<");
                    for (var i = 0; i < symbol.TypeParameters.Length; i++)
                    {
                        if (i != 0)
                            nameBuilder.Append(", ");
                        nameBuilder.Append(symbol.TypeParameters[i]);
                    }
                    nameBuilder.Append(">");
                }
                var name = nameBuilder.ToString();
                var prefix = symbol.IsAbstract ? "protected" : "private";
                builder.AppendLine(@$"namespace {symbol.ContainingNamespace.ToDisplayString()}
{{
    {name}
    {{
#nullable enable        
        private IAsyncStream<NodeModifiedEvent>? _notifyModifiedEventStream;
        {prefix} IAsyncStream<NodeModifiedEvent>? NotifyModifiedEventStream
            => _notifyModifiedEventStream ??=
                State.Command is not null && State.Command.Root != default ? StreamProvider.GetStream<NodeModifiedEvent>(State.Command.Root) : null;

        private IAsyncStream<NodeExecutingEvent>? _notifyExecutingEventStream;
        {prefix} IAsyncStream<NodeExecutingEvent>? NotifyExecutingEventStream
            => _notifyExecutingEventStream ??=
                State.Command is not null && State.Command.Root != default ? StreamProvider.GetStream<NodeExecutingEvent>(State.Command.Root) : null;

        private IAsyncStream<NodeCompletedEvent>? _notifyCompletedEventStream;
        {prefix} IAsyncStream<NodeCompletedEvent>? NotifyCompletedEventStream
            => _notifyCompletedEventStream ??=
                State.Command is not null && State.Command.Root != default ? StreamProvider.GetStream<NodeCompletedEvent>(State.Command.Root) : null;

        private IAsyncStream<NodeCancelledEvent>? _notifyCancelledEventStream;
        {prefix} IAsyncStream<NodeCancelledEvent>? NotifyCancelledEventStream
            => _notifyCancelledEventStream ??=
                State.Command is not null && State.Command.Root != default ? StreamProvider.GetStream<NodeCancelledEvent>(State.Command.Root) : null;
    
        private IAsyncStream<NodeCleanedEvent>? _notifyCleanedEventStream;
        {prefix} IAsyncStream<NodeCleanedEvent>? NotifyCleanedEventStream
            => _notifyCleanedEventStream ??=
                State.Command is not null && State.Command.Root != default ? StreamProvider.GetStream<NodeCleanedEvent>(State.Command.Root) : null;
    }}
}}");
                context.AddSource($"{symbol.Name}.parent.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
            });
        }
    }
}
