using System.Text;
using static Testly.Domain.Analyzers.ScheduledNodeSyntaxProvider;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Testly.Domain.Analyzers
{
    [Generator]
#pragma warning disable RS1036 // 指定分析器禁止的 API 强制设置
    internal class ScheduledNodeIncrementalGenerator : IIncrementalGenerator
#pragma warning restore RS1036 // 指定分析器禁止的 API 强制设置
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterSourceOutput(context.SyntaxProvider.CreateSyntaxProvider(Predicate, Transform), (context, symbol) =>
            {
                var builder = new StringBuilder();
                builder.AppendLine("// <auto-generated />");
                builder.AppendLine();
                builder.AppendLine("using Orleans.Streams;");
                builder.AppendLine("using Testly.Domain.Events;");
                var nameBuilder = new StringBuilder();
                nameBuilder.Append(symbol.IsAbstract ? "public abstract partial class " : "internal sealed partial class ");
                nameBuilder.Append(symbol.Name);
                if (symbol.TypeParameters.Length > 0)
                {
                    nameBuilder.Append("<");
                    for (var i = 0; i < symbol.TypeParameters.Length; i++)
                    {
                        if (i != 0)
                            nameBuilder.Append(", ");
                        nameBuilder.Append(symbol.TypeParameters[i]);
                    }
                    nameBuilder.Append(">");
                }
                var name = nameBuilder.ToString();
                var prefix = symbol.IsAbstract ? "protected" : "private";
                builder.AppendLine(@$"namespace {symbol.ContainingNamespace.ToDisplayString()}
{{
    {name}
    {{
#nullable enable
        private IAsyncStream<ScheduledNodeCompletedEvent>? _lastNodeCompletedEventStream;
        {prefix} IAsyncStream<ScheduledNodeCompletedEvent>? LastNodeCompletedEventStream
            => _lastNodeCompletedEventStream ??=
                (State.Command?.LastId is null ? null : StreamProvider.GetStream<ScheduledNodeCompletedEvent>(State.Command.LastId));
        
        private IAsyncStream<ScheduledNodeCleanedEvent>? _lastNodeCleanedEventStream;
        {prefix} IAsyncStream<ScheduledNodeCleanedEvent>? LastNodeCleanedEventStream
            => _lastNodeCleanedEventStream ??=
                (State.Command?.LastId is null ? null : StreamProvider.GetStream<ScheduledNodeCleanedEvent>(State.Command.LastId));

        private IAsyncStream<ScheduledNodeModifiedEvent>? _lastNodeModifiedEventStream;
        {prefix} IAsyncStream<ScheduledNodeModifiedEvent>? LastNodeModifiedEventStream
            => _lastNodeModifiedEventStream ??=
                (State.Command?.LastId is null ? null : StreamProvider.GetStream<ScheduledNodeModifiedEvent>(State.Command.LastId));
    }}
}}");
                context.AddSource($"{symbol.Name}.last.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
            });
        }
    }
}
