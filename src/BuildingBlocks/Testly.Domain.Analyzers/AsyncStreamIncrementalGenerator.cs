using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Testly.Domain.Attributes;
using static Testly.Domain.Analyzers.AsyncStreamSyntaxProvider;

namespace Testly.Domain.Analyzers
{
    [Generator]
    internal class AsyncStreamIncrementalGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider.ForAttributeWithMetadataName("Testly.Domain.Attributes.AsyncStreamAttribute", (node, cancellationToken) =>
                node is VariableDeclaratorSyntax
                {
                    Parent: VariableDeclarationSyntax
                    {
                        Parent: FieldDeclarationSyntax
                        {
                            AttributeLists.Count: > 0,
                        }
                    }
                } && ((FieldDeclarationSyntax)(node.Parent.Parent)).AttributeLists
                    .SelectMany(attributeListSyntax => attributeListSyntax.Attributes)
                    .Any(attribute => attribute.Name.ToString() == "AsyncStream"), 
                    (context, cancellationToken) => (IFieldSymbol)context.TargetSymbol);

            context.RegisterSourceOutput(provider, (context, field) =>
            {
                var info = field.ContainingType;
                var name = field.Name.Substring(1, field.Name.Length - 1);
                var sub = name.Length > 1 ? name.Substring(1, name.Length - 1) : string.Empty;
                name = $"{char.ToUpper(name[0])}{sub}";

                var typeName = field.Type.ToDisplayString();
                var index = typeName.LastIndexOf('.');
                typeName = typeName.Substring(index + 1, typeName.Length - index - 2);

                var builder = new StringBuilder();
                builder.AppendLine("// <auto-generated />");

                builder.AppendLine();
                builder.AppendLine($@"namespace {info.ContainingNamespace.ToDisplayString()}
{{");
                if (info.IsAbstract)
                    builder.Append($@"   public abstract partial class {info.Name}");
                else
                    builder.Append($@"   internal partial class {info.Name}");

                if (info.TypeArguments.Length > 0)
                {
                    builder.Append('<');
                    for (var i = 0; i < info.TypeArguments.Length; i++)
                    {
                        if (i > 0)
                            builder.Append(", ");
                        builder.Append(info.TypeArguments[i].Name);
                    }
                    builder.Append('>');
                }

                builder.AppendLine($@"
    {{
        protected {typeName} {name}
            => {field.Name} ??= {}
    }}
}}");
                context.AddSource($"{info.Name}.{name}.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
            });
        }

    }
}
